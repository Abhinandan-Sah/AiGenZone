import express from "express"
import archiver from "archiver"
import { authenticateToken, type AuthRequest } from "../middleware/auth"
import { Component } from "../models/Component"
import { logger } from "../utils/logger"

const router = express.Router()

// Export component as ZIP
router.post("/component/:componentId", authenticateToken, async (req: AuthRequest, res, next) => {
  try {
    const { componentId } = req.params
    const userId = req.user._id

    const component = await Component.findOne({
      _id: componentId,
      userId,
      isActive: true,
    })

    if (!component) {
      return res.status(404).json({ error: "Component not found" })
    }

    // Create ZIP archive
    const archive = archiver("zip", { zlib: { level: 9 } })

    // Set response headers
    const componentName = component.name.toLowerCase().replace(/\s+/g, "-")
    res.setHeader("Content-Type", "application/zip")
    res.setHeader("Content-Disposition", `attachment; filename="${componentName}.zip"`)

    // Pipe archive to response
    archive.pipe(res)

    // Add component files
    const tsxFileName = `${componentName}.tsx`
    const cssFileName = `${componentName}.module.css`

    // Add TypeScript component file
    archive.append(component.jsxCode, { name: tsxFileName })

    // Add CSS file if exists
    if (component.cssCode) {
      archive.append(component.cssCode, { name: cssFileName })
    }

    // Add package.json
    const packageJson = {
      name: componentName,
      version: `1.${component.version}.0`,
      description: component.description || `Generated component: ${component.name}`,
      main: tsxFileName,
      scripts: {
        build: "tsc",
        dev: "tsc --watch",
      },
      dependencies: {
        react: "^18.0.0",
        "@types/react": "^18.0.0",
        ...(component.metadata.dependencies?.reduce((acc: any, dep: string) => {
          acc[dep] = "latest"
          return acc
        }, {}) || {}),
      },
      devDependencies: {
        typescript: "^5.0.0",
        "@types/node": "^20.0.0",
      },
    }
    archive.append(JSON.stringify(packageJson, null, 2), { name: "package.json" })

    // Add TypeScript config
    const tsConfig = {
      compilerOptions: {
        target: "es5",
        lib: ["dom", "dom.iterable", "es6"],
        allowJs: true,
        skipLibCheck: true,
        esModuleInterop: true,
        allowSyntheticDefaultImports: true,
        strict: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node",
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        jsx: "react-jsx",
      },
      include: ["**/*"],
      exclude: ["node_modules"],
    }
    archive.append(JSON.stringify(tsConfig, null, 2), { name: "tsconfig.json" })

    // Add README
    const readme = `# ${component.name}

${component.description || "Generated React component using AiGenZone"}

## Installation

\`\`\`bash
npm install
\`\`\`

## Usage

\`\`\`tsx
import ${component.name} from './${tsxFileName}';
${component.cssCode ? `import './${cssFileName}';` : ""}

function App() {
  return <${component.name} />;
}
\`\`\`

## Props

${
  component.metadata.props
    ? Object.entries(component.metadata.props)
        .map(([key, type]) => `- \`${key}\`: ${type}`)
        .join("\n")
    : "No props defined"
}

## Dependencies

${component.metadata.dependencies?.map((dep: string) => `- ${dep}`).join("\n") || "No additional dependencies"}

---

Generated by AiGenZone on ${new Date().toISOString()}
Version: ${component.version}
`
    archive.append(readme, { name: "README.md" })

    // Finalize archive
    await archive.finalize()

    logger.info(`Component exported: ${component.name} by user ${userId}`)
  } catch (error) {
    logger.error("Export error:", error)
    next(error)
  }
})

// Export session (all components)
router.post("/session/:sessionId", authenticateToken, async (req: AuthRequest, res, next) => {
  try {
    const { sessionId } = req.params
    const userId = req.user._id

    const components = await Component.find({
      sessionId,
      userId,
      isActive: true,
    }).populate("sessionId", "name")

    if (components.length === 0) {
      return res.status(404).json({ error: "No components found in session" })
    }

    // Create ZIP archive
    const archive = archiver("zip", { zlib: { level: 9 } })

    // Set response headers
    const sessionName = (components[0].sessionId as any).name.toLowerCase().replace(/\s+/g, "-")
    res.setHeader("Content-Type", "application/zip")
    res.setHeader("Content-Disposition", `attachment; filename="${sessionName}-components.zip"`)

    // Pipe archive to response
    archive.pipe(res)

    // Add each component
    for (const component of components) {
      const componentName = component.name.toLowerCase().replace(/\s+/g, "-")
      const componentDir = `components/${componentName}/`

      // Add component files
      archive.append(component.jsxCode, { name: `${componentDir}${componentName}.tsx` })

      if (component.cssCode) {
        archive.append(component.cssCode, { name: `${componentDir}${componentName}.module.css` })
      }

      // Add component README
      const componentReadme = `# ${component.name}

${component.description || ""}

Version: ${component.version}
Created: ${component.createdAt}
Updated: ${component.updatedAt}
`
      archive.append(componentReadme, { name: `${componentDir}README.md` })
    }

    // Add main package.json
    const mainPackageJson = {
      name: sessionName,
      version: "1.0.0",
      description: `Component collection from AiGenZone session: ${(components[0].sessionId as any).name}`,
      scripts: {
        build: "tsc",
        dev: "tsc --watch",
      },
      dependencies: {
        react: "^18.0.0",
        "@types/react": "^18.0.0",
      },
      devDependencies: {
        typescript: "^5.0.0",
      },
    }
    archive.append(JSON.stringify(mainPackageJson, null, 2), { name: "package.json" })

    // Finalize archive
    await archive.finalize()

    logger.info(`Session exported: ${sessionId} by user ${userId}`)
  } catch (error) {
    logger.error("Session export error:", error)
    next(error)
  }
})

export default router
